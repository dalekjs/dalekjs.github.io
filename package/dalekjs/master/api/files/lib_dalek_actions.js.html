<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/dalek/actions.js - dalekjs</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="dalekjs"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.8</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Actions.html">Actions</a></li>
            
                <li><a href="../classes/Dalek.html">Dalek</a></li>
            
                <li><a href="../classes/Dalek.Config.html">Dalek.Config</a></li>
            
                <li><a href="../classes/Dalek.Driver.html">Dalek.Driver</a></li>
            
                <li><a href="../classes/Dalek.Internal.Assertions.html">Dalek.Internal.Assertions</a></li>
            
                <li><a href="../classes/Dalek.Remote.html">Dalek.Remote</a></li>
            
                <li><a href="../classes/Dalek.Reporter.html">Dalek.Reporter</a></li>
            
                <li><a href="../classes/Dalek.Suite.html">Dalek.Suite</a></li>
            
                <li><a href="../classes/Dalek.Timer.html">Dalek.Timer</a></li>
            
                <li><a href="../classes/Dalek.Unit.html">Dalek.Unit</a></li>
            
                <li><a href="../classes/Host.html">Host</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Assertions.html">Assertions</a></li>
            
                <li><a href="../modules/Dalek.html">Dalek</a></li>
            
                <li><a href="../modules/DalekJS.html">DalekJS</a></li>
            
                <li><a href="../modules/Remote.html">Remote</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/dalek/actions.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 *
 * Copyright (c) 2013 Sebastian Golasch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the &quot;Software&quot;),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

&#x27;use strict&#x27;;

// ext. libs
var Q = require(&#x27;q&#x27;);
var uuid = require(&#x27;./uuid&#x27;);
var cheerio = require(&#x27;cheerio&#x27;);

// int. global
var reporter = null;

/**
 * Actions are a way to control your browsers, e.g. simulate user interactions
 * like clicking elements, open urls, filling out input fields, etc.
 *
 * @class Actions
 * @constructor
 * @part Actions
 * @api
 */

var Actions = function () {
  this.uuids = {};
};

/**
 * It can be really cumbersome to repeat selectors all over when performing
 * multiple actions or assertions on the same element(s).
 * When you use the query method (or its alias $), you&#x27;re able to specify a
 * selector once instead of repeating it all over the place.
 *
 * So, instead of writing this:
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://doctorwhotv.co.uk/&#x27;)
 *     .assert.text(&#x27;#nav&#x27;).is(&#x27;Navigation&#x27;)
 *     .assert.visible(&#x27;#nav&#x27;)
 *     .assert.attr(&#x27;#nav&#x27;, &#x27;data-nav&#x27;, &#x27;true&#x27;)
 *     .click(&#x27;#nav&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * you can write this:
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://doctorwhotv.co.uk/&#x27;)
 *     .query(&#x27;#nav&#x27;)
 *       .assert.text().is(&#x27;Navigation&#x27;)
 *       .assert.visible()
 *       .assert.attr(&#x27;data-nav&#x27;, &#x27;true&#x27;)
 *       .click()
 *     .end()
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * Always make sure to terminate it with the [end](assertions.html#meth-end) method!
 *
 * @api
 * @method query
 * @param {string} selector Selector of the element to query
 * @chainable
 */

Actions.prototype.query = function (selector) {
  var that = !this.test ? this : this.test;
  that.lastChain.push(&#x27;querying&#x27;);
  that.selector = selector;
  that.querying = true;
  return this.test ? this : that;
};

/**
 * Alias of query
 *
 * @api
 * @method $
 * @param {string} selector Selector of the element to query
 * @chainable
 */

Actions.prototype.$ = Actions.prototype.query;

/**
 * Triggers a mouse event on the first element found matching the provided selector.
 * Supported events are mouseup, mousedown, click, mousemove, mouseover and mouseout.
 * TODO: IMPLEMENT
 *
 * @method mouseEvent
 * @param {string} type
 * @param {string} selector
 * @chainable
 */

Actions.prototype.mouseEvent = function (type, selector) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;mouseEvent&#x27;, &#x27;mouseEvent&#x27;, type, selector, hash);
  this._addToActionQueue([type, selector, hash], &#x27;mouseEvent&#x27;, cb);
  return this;
};

/**
 * Sets HTTP_AUTH_USER and HTTP_AUTH_PW values for HTTP based authentication systems.
 *
 * If your site is behind a HTTP basic auth, you&#x27;re able to set the username and the password
 *
 * &#x60;&#x60;&#x60;javascript
 * test.setHttpAuth(&#x27;OSWIN&#x27;, &#x27;rycbrar&#x27;)
 *     .open(&#x27;http://admin.therift.com&#x27;);
 * &#x60;&#x60;&#x60;
 *
 * Most of the time, you&#x60;re not storing your passwords within files that will be checked
 * in your vcs, for this scenario, you have two options:
 *
 * The first option is, to use daleks cli capabilities to generate config variables
 * from the command line, like this
 *
 * &#x60;&#x60;&#x60;batch
 * $ dalek --vars USER=OSWIN,PASS=rycbrar
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.setHttpAuth(test.config.get(&#x27;USER&#x27;), test.config.get(&#x27;PASS&#x27;))
 *     .open(&#x27;http://admin.therift.com&#x27;);
 * &#x60;&#x60;&#x60;
 *
 * The second option is, to use env variables to generate config variables
 * from the command line, like this
 *
 * &#x60;&#x60;&#x60;batch
 * $ SET USER=OSWIN
 * $ SET PASS=rycbrar
 * $ dalek
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.setHttpAuth(test.config.get(&#x27;USER&#x27;), test.config.get(&#x27;PASS&#x27;))
 *     .open(&#x27;http://admin.therift.com&#x27;);
 * &#x60;&#x60;&#x60;
 *
 * If both, dalek variables &amp; env variables are set, the dalek variables win.
 * For more information about this, I recommend to check out the [configuration docs](/docs/config.html)
 *
 * TODO: IMPLEMENT
 * 
 * @method setHttpAuth
 * @param {string} username
 * @param {string} password
 * @return {Actions}
 */

Actions.prototype.setHttpAuth = function (username, password) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;setHttpAuth&#x27;, &#x27;setHttpAuth&#x27;, username, password, hash);
  this._addToActionQueue([username, password, hash], &#x27;setHttpAuth&#x27;, cb);
  return this;
};

/**
 * Switches to an iFrame context
 *
 * Sometimes you encounter situations, where you need to drive/access an iFrame sitting in your page.
 * You can access such frames with this method, but be aware of the fact, that the complete test context
 * than switches to the iframe context, every action and assertion will be executed within the iFrame context.
 * Btw.: The domain of the IFrame can be whatever you want, this method has no same origin policy restrictions.
 *
 * If you wan&#x27;t to get back to the parents context, you have to use the [toParent](#meth-toParent) method.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div&gt;
 *   &lt;iframe id=&quot;login&quot; src=&quot;/login.html&quot;/&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.withiframe.com&#x27;)
 *    .assert.title().is(&#x27;Title of a page that embeds an iframe&#x27;)
 *    .toFrame(&#x27;#login&#x27;)
 *      .assert.title().is(&#x27;Title of a page that can be embedded as an iframe&#x27;)
 *    .toParent()
 *    .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; NOTE: Buggy in Firefox
 * 
 * @api
 * @method toFrame
 * @param {string} selector Selector of the frame to switch to
 * @chainable
 */

Actions.prototype.toFrame = function (selector) {
  var hash = uuid();

  if (this.querying === true) {
    selector = this.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;toFrame&#x27;, &#x27;toFrame&#x27;, selector, hash);
  this._addToActionQueue([selector, hash], &#x27;toFrame&#x27;, cb);
  return this;
};

/**
 * Switches back to the parent page context when the test context has been
 * switched to an iFrame context
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div&gt;
 *   &lt;iframe id=&quot;login&quot; src=&quot;/login.html&quot;/&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.withiframe.com&#x27;)
 *    .assert.title().is(&#x27;Title of a page that embeds an iframe&#x27;)
 *    .toFrame(&#x27;#login&#x27;)
 *      .assert.title().is(&#x27;Title of a page that can be embedded as an iframe&#x27;)
 *    .toParent()
 *    .assert.title().is(&#x27;Title of a page that embeds an iframe&#x27;)
 *    .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; NOTE: Buggy in Firefox
 * 
 * @api
 * @method toParent
 * @chainable
 */

Actions.prototype.toParent = function () {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;toFrame&#x27;, &#x27;toFrame&#x27;, null, hash);
  this._addToActionQueue([null, hash], &#x27;toFrame&#x27;, cb);
  return this;
};

/**
 * Switches to a different window context
 *
 * Sometimes you encounter situations, where you need to access a different window, like popup windows.
 * You can access such windows with this method, but be aware of the fact, that the complete test context
 * than switches to the window context, every action and assertion will be executed within the chosen window context.
 * Btw.: The domain of the window can be whatever you want, this method has no same origin policy restrictions.
 *
 * If you want to get back to the parents context, you have to use the [toParentWindow](#meth-toParentWindow) method.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div&gt;
 *   &lt;a onclick=&quot;window.open(&#x27;http://google.com&#x27;,&#x27;goog&#x27;,&#x27;width=480, height=300&#x27;)&quot;&gt;Open Google&lt;/a&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *    .assert.title().is(&#x27;Title of a page that can open a popup window&#x27;)
 *    .toWindow(&#x27;goog&#x27;)
 *      .assert.title().is(&#x27;Google&#x27;)
 *    .toParentWindow()
 *    .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; NOTE: Buggy in Firefox
 * 
 * @api
 * @method toWindow
 * @param {string} name Name of the window to switch to
 * @chainable
 */

Actions.prototype.toWindow = function (name) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;toWindow&#x27;, &#x27;toWindow&#x27;, name, hash);
  this._addToActionQueue([name, hash], &#x27;toWindow&#x27;, cb);
  return this;
};

/**
 * Switches back to the parent window context when the test context has been
 * switched to a different window context
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div&gt;
 *   &lt;a onclick=&quot;window.open(&#x27;http://google.com&#x27;,&#x27;goog&#x27;,&#x27;width=480, height=300&#x27;)&quot;&gt;Open Google&lt;/a&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *    .assert.title().is(&#x27;Title of a page that can open a popup window&#x27;)
 *    .toWindow(&#x27;goog&#x27;)
 *      .assert.title().is(&#x27;Google&#x27;)
 *    .toParentWindow()
 *    .assert.title().is(&#x27;Title of a page that can open a popup window&#x27;)
 *    .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; NOTE: Buggy in Firefox
 * 
 * @api
 * @method toParentWindow
 * @chainable
 */

Actions.prototype.toParentWindow = function () {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;toWindow&#x27;, &#x27;toWindow&#x27;, null, hash);
  this._addToActionQueue([null, hash], &#x27;toWindow&#x27;, cb);
  return this;
};

/**
 * Wait until a resource that matches the given testFx is loaded to process a next step.
 *
 * TODO: IMPLEMENT
 * 
 * @method waitForResource
 * @param {string} ressource URL of the ressource that should be waited for
 * @param {number} timeout Timeout in miliseconds
 * @chainable
 */

Actions.prototype.waitForResource = function (ressource, timeout) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;waitForResource&#x27;, &#x27;waitForResource&#x27;, ressource, timeout, hash);
  this._addToActionQueue([ressource, (timeout ? parseInt(timeout, 10) : 5000), hash], &#x27;waitForResource&#x27;, cb);
  return this;
};

/**
 * Waits until the passed text is present in the page contents before processing the immediate next step.
 *
 * TODO: IMPLEMENT
 * 
 * @method waitForText
 * @param {string} text Text to be waited for
 * @param {number} timeout Timeout in miliseconds
 * @chainable
 */

Actions.prototype.waitForText = function (text, timeout) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;waitForText&#x27;, &#x27;waitForText&#x27;, text, timeout, hash);
  this._addToActionQueue([text, (timeout ? parseInt(timeout, 10) : 5000), hash], &#x27;waitForText&#x27;, cb);
  return this;
};

/**
 * Waits until an element matching the provided selector expression is visible in the remote DOM to process a next step.
 *
 * TODO: IMPLEMENT
 * 
 * @method waitUntilVisible
 * @param {string} selector Selector of the element that should be waited to become invisible
 * @param {number} timeout Timeout in miliseconds
 * @chainable
 */

Actions.prototype.waitUntilVisible = function (selector, timeout) {
  var hash = uuid();

  if (this.querying === true) {
    timeout = selector;
    selector = this.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;waitUntilVisible&#x27;, &#x27;waitUntilVisible&#x27;, selector, timeout, hash);
  this._addToActionQueue([selector, (timeout ? parseInt(timeout, 10) : 5000), hash], &#x27;waitUntilVisible&#x27;, cb);
  return this;
};

/**
 * Waits until an element matching the provided selector expression is no longer visible in remote DOM to process a next step.
 *
 * TODO: IMPLEMENT
 * 
 * @method waitWhileVisible
 * @param {string} selector Selector of the element that should be waited to become visible
 * @param {number} timeout Timeout in miliseconds
 * @chainable
 */

Actions.prototype.waitWhileVisible = function (selector, timeout) {
  var hash = uuid();

  if (this.querying === true) {
    timeout = selector;
    selector = this.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;waitWhileVisible&#x27;, &#x27;waitWhileVisible&#x27;, selector, timeout, hash);
  this._addToActionQueue([selector, (timeout ? parseInt(timeout, 10) : 5000), hash], &#x27;waitWhileVisible&#x27;, cb);
  return this;
};

/**
 * Take a screenshot of the current page.
 *
 * The pathname argument takes some placeholders that will be replaced
 * Placeholder:
 *
 *   - &#x60;:browser&#x60; - The browser name (e.g. &#x27;Chrome&#x27;, &#x27;Safari&#x27;, &#x27;Firefox&#x27;, etc.)
 *   - &#x60;:version&#x60; -  The browser version (e.g. &#x27;10_0&#x27;, &#x27;23_11_5&#x27;, etc.)
 *   - &#x60;:os&#x60; - The operating system (e.g. &#x60;OSX&#x60;, &#x60;Windows&#x60;, &#x60;Linux&#x60;)
 *   - &#x60;:osVersion&#x60; - The operating system version (e.g &#x60;XP&#x60;, &#x60;7&#x60;, &#x60;10_8&#x60;, etc.)
 *   - &#x60;:viewport&#x60; - The current viewport in pixels (e.g. &#x60;w1024_h768&#x60;)
 *   - &#x60;:timestamp&#x60; - UNIX like timestapm (e.g. &#x60;637657345&#x60;)
 *   - &#x60;:date&#x60; - Current date in format MM_DD_YYYY (e.g. &#x60;12_24_2013&#x60;)
 *   - &#x60;:datetime&#x60; - Current datetime in format MM_DD_YYYY_HH_mm_ss (e.g. &#x60;12_24_2013_14_55_23&#x60;)
 *
 * &#x60;&#x60;&#x60;javascript
 * // creates &#x27;my/folder/my_file.png&#x27;
 * test.screenshot(&#x27;my/folder/my_file&#x27;);
 * // creates &#x27;my/page/in/safari/homepage.png&#x27;
 * test.screenshot(&#x27;my/page/in/:browser/homepage&#x27;);
 * // creates &#x27;my/page/in/safari_6_0_1/homepage.png&#x27;
 * test.screenshot(&#x27;my/page/in/:browser_:version/homepage&#x27;);
 * // creates &#x27;my/page/in/safari_6_0_1/on/osx/homepage.png&#x27;
 * test.screenshot(&#x27;my/page/in/:browser_:version/on/:os/homepage&#x27;);
 * // creates &#x27;my/page/in/safari_6_0_1/on/osx_10_8/homepage.png&#x27;
 * test.screenshot(&#x27;my/page/in/:browser_:version/on/:os_:osVersion/homepage&#x27;);
 * // creates &#x27;my/page/at/w1024_h768/homepage.png&#x27;
 * test.screenshot(&#x27;my/page/at/:viewport/homepage&#x27;);
 * // creates &#x27;my/page/at/637657345/homepage.png&#x27;
 * test.screenshot(&#x27;my/page/in_time/:timestamp/homepage&#x27;);
 * // creates &#x27;my/page/at/12_24_2013/homepage.png&#x27;
 * test.screenshot(&#x27;my/page/in_time/:date/homepage&#x27;);
 * // creates &#x27;my/page/at/12_24_2013_14_55_23/homepage.png&#x27;
 * test.screenshot(&#x27;my/page/in_time/:datetime/homepage&#x27;);
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method screenshot
 * @param {string} pathname Name of the folder and file the screenshot should be saved to
 * @return chainable
 */

Actions.prototype.screenshot = function (pathname) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;screenshot&#x27;, &#x27;screenshot&#x27;, pathname, hash);
  this._addToActionQueue([&#x27;&#x27;, pathname, hash], &#x27;screenshot&#x27;, cb);
  return this;
};

/**
 * Pause steps suite execution for a given amount of time, and optionally execute a step on done.
 *
 * This makes sense, if you have a ticker for example, tht scrolls like every ten seconds
 * &amp; you want to assure that the visible content changes every ten seconds
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://myticker.org&#x27;)
 *   .assert.visible(&#x27;.ticker-element:first-child&#x27;, &#x27;First ticker element is visible&#x27;)
 *   .wait(10000)
 *   .assert.visible(&#x27;.ticker-element:nth-child(2)&#x27;, &#x27;Snd. ticker element is visible&#x27;)
 *   .wait(10000)
 *   .assert.visible(&#x27;.ticker-element:last-child&#x27;, &#x27;Third ticker element is visible&#x27;)
 *   .done();
 * &#x60;&#x60;&#x60;
 * If no timeout argument is given, a default timeout of 5 seconds will be used
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://myticker.org&#x27;)
 *   .assert.visible(&#x27;.ticker-element:first-child&#x27;, &#x27;First ticker element is visible&#x27;)
 *   .wait()
 *   .assert.visible(&#x27;.ticker-element:nth-child(2)&#x27;, &#x27;Snd. ticker element is visible&#x27;)
 *   .wait()
 *   .assert.visible(&#x27;.ticker-element:last-child&#x27;, &#x27;Third ticker element is visible&#x27;)
 *   .done();
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method wait
 * @param {number} timeout in milliseconds
 * @chainable
 */

Actions.prototype.wait = function (timeout) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;wait&#x27;, &#x27;wait&#x27;, timeout, hash);
  this._addToActionQueue([(timeout ? parseInt(timeout, 10) : 5000), hash], &#x27;wait&#x27;, cb);
  return this;
};

/**
 * Reloads current page location.
 *
 * This is basically the same as hitting F5/refresh in your browser
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://google.com&#x27;)
 *   .reload()
 *   .done();
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method reload
 * @chainable
 */

Actions.prototype.reload = function () {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;refresh&#x27;, &#x27;refresh&#x27;, &#x27;&#x27;, hash);
  this._addToActionQueue([hash], &#x27;refresh&#x27;, cb);
  return this;
};

/**
 * Moves a step forward in browser&#x27;s history.
 *
 * This is basically the same as hitting the forward button in your browser
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://google.com&#x27;)
 *   .open(&#x27;https://github.com&#x27;)
 *   .assert.url.is(&#x27;https://github.com/&#x27;, &#x27;We are at GitHub&#x27;)
 *   .back()
 *   .assert.url.is(&#x27;http://google.com&#x27;, &#x27;We are at Google!&#x27;)
 *   .forward()
 *   .assert.url.is(&#x27;https://github.com/&#x27;, &#x27;Back at GitHub! Timetravel FTW&#x27;)
 *   .done();
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method forward
 * @chainable
 */

Actions.prototype.forward = function () {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;forward&#x27;, &#x27;forward&#x27;, &#x27;&#x27;, hash);
  this._addToActionQueue([hash], &#x27;forward&#x27;, cb);
  return this;
};

/**
 * Moves back a step in browser&#x27;s history.
 *
 * This is basically the same as hitting the back button in your browser
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://google.com&#x27;)
 *   .open(&#x27;https://github.com&#x27;)
 *   .assert.url.is(&#x27;https://github.com/&#x27;, &#x27;We are at GitHub&#x27;)
 *   .back()
 *   .assert.url.is(&#x27;http://google.com&#x27;, &#x27;We are at Google!&#x27;)
 *   .forward()
 *   .assert.url.is(&#x27;https://github.com/&#x27;, &#x27;Back at GitHub! Timetravel FTW&#x27;);
 *   .done();
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method back
 * @chainable
 */

Actions.prototype.back = function () {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;back&#x27;, &#x27;back&#x27;, &#x27;&#x27;, hash);
  this._addToActionQueue([hash], &#x27;back&#x27;, cb);
  return this;
};

/**
 * Performs a click on the element matching the provided selector expression.
 *
 * If we take Daleks homepage (the one you&#x27;re probably visiting right now),
 * the HTML looks something like this (it does not really, but hey, lets assume this for a second)
 *
 * &#x60;&#x60;&#x60;html
 * &lt;nav&gt;
 *   &lt;ul&gt;
 *     &lt;li&gt;&lt;a id=&quot;homeapge&quot; href=&quot;/index.html&quot;&gt;DalekJS&lt;/a&gt;&lt;/li&gt;
 *     &lt;li&gt;&lt;a id=&quot;docs&quot; href=&quot;/docs.html&quot;&gt;Documentation&lt;/a&gt;&lt;/li&gt;
 *     &lt;li&gt;&lt;a id=&quot;faq&quot; href=&quot;/faq.html&quot;&gt;F.A.Q&lt;/a&gt;&lt;/li&gt;
 *   &lt;/ul&gt;
 * &lt;/nav&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://dalekjs.com&#x27;)
 *     .click(&#x27;#faq&#x27;)
 *     .assert.title().is(&#x27;DalekJS - Frequently asked questions&#x27;, &#x27;What the F.A.Q.&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * By default, this performs a left click.
 * In the future it might become the ability to also execute a &quot;right button&quot; click.
 *
 * &gt; Note: Does not work correctly in Firefox when used on &#x60;&lt;select&gt;&#x60; &amp; &#x60;&lt;option&gt;&#x60; elements
 * 
 * @api
 * @method click
 * @param {string} selector Selector of the element to be clicked
 * @chainable
 */

Actions.prototype.click = function (selector) {
  var hash = uuid();

  if (this.querying === true) {
    selector = this.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;click&#x27;, &#x27;click&#x27;, selector, hash);
  this._addToActionQueue([selector, hash], &#x27;click&#x27;, cb);
  return this;
};

/**
 * Submits a form.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;form id=&quot;skaaro&quot; action=&quot;skaaro.php&quot; method=&quot;GET&quot;&gt;
 *   &lt;input type=&quot;hidden&quot; name=&quot;intheshadows&quot; value=&quot;itis&quot;/&gt;
 *   &lt;input type=&quot;text&quot; name=&quot;truth&quot; id=&quot;truth&quot; value=&quot;&quot;/&gt;
 * &lt;/form&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://home.dalek.com&#x27;)
 *     .type(&#x27;#truth&#x27;, &#x27;out there is&#x27;)
 *     .submit(&#x27;#skaaro&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; Note: Does not work in Firefox yet
 * 
 * @api
 * @method submit
 * @param {string} selector Selector of the form to be submitted
 * @chainable
 */

Actions.prototype.submit = function (selector) {
  var hash = uuid();

  if (this.querying === true) {
    selector = this.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;submit&#x27;, &#x27;submit&#x27;, selector, hash);
  this._addToActionQueue([selector, hash], &#x27;submit&#x27;, cb);
  return this;
};

/**
 * Performs an HTTP request for opening a given location.
 * You can forge GET, POST, PUT, DELETE and HEAD requests.
 *
 * Basically the same as typing a location into your browsers URL bar and
 * hitting return.
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://dalekjs.com&#x27;)
 *     .assert.url().is(&#x27;http://dalekjs.com&#x27;, &#x27;DalekJS I\&#x27;m in you&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method open
 * @param {string} location URL of the page to open
 * @chainable
 */

Actions.prototype.open = function (location) {
  //see if we should prepend the location with the configured base url is available and needed
  if(location.substr(0, 1) === &#x27;/&#x27; &amp;&amp; this.driver.config.config.baseUrl) {
    location = this.driver.config.config.baseUrl + location;
  }

  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;open&#x27;, &#x27;open&#x27;, location, hash);
  this._addToActionQueue([location, hash], &#x27;open&#x27;, cb);
  return this;
};

/**
 * Types a text into an input field or text area.
 * And yes, it really types, character for character, like you would
 * do when using your keyboard.
 *
 *
 * &#x60;&#x60;&#x60;html
 * &lt;form id=&quot;skaaro&quot; action=&quot;skaaro.php&quot; method=&quot;GET&quot;&gt;
 *   &lt;input type=&quot;hidden&quot; name=&quot;intheshadows&quot; value=&quot;itis&quot;/&gt;
 *   &lt;input type=&quot;text&quot; name=&quot;truth&quot; id=&quot;truth&quot; value=&quot;&quot;/&gt;
 * &lt;/form&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://home.dalek.com&#x27;)
 *     .type(&#x27;#truth&#x27;, &#x27;out there is&#x27;)
 *     .assert.val(&#x27;#truth&#x27;, &#x27;out there is&#x27;, &#x27;Text has been set&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * You can also send special keys using unicode.
 *
 *  * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://home.dalek.com&#x27;)
 *     .type(&#x27;#truth&#x27;, &#x27;out \uE008there\uE008 is&#x27;)
 *     .assert.val(&#x27;#truth&#x27;, &#x27;out THERE is&#x27;, &#x27;Text has been set&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 * You can go [here](https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/element/:id/value) to read up on special keys and unicodes for them (note that a code of U+EXXX is actually written in code as \uEXXX).
 *
 * &gt; Note: Does not work correctly in Firefox with special keys
 * 
 * @api
 * @method type
 * @param {string} selector Selector of the form field to be filled
 * @param {string} keystrokes Text to be applied to the element
 * @chainable
 */

Actions.prototype.type = function (selector, keystrokes) {
  var hash = uuid();

  if (this.querying === true) {
    keystrokes = selector;
    selector = this.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;type&#x27;, &#x27;type&#x27;, selector, keystrokes, hash);
  this._addToActionQueue([selector, keystrokes], &#x27;type&#x27;, cb);
  return this;
};

/**
 * This acts just like .type() with a key difference.
 * This action can be used on non-input elements (useful for test site wide keyboard shortcuts and the like).
 * So assumeing we have a keyboard shortcut that display an alert box, we could test that with something like this:
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://home.dalek.com&#x27;)
 *     .sendKeys(&#x27;body&#x27;, &#x27;\uE00C&#x27;)
 *     .assert.dialogText(&#x27;press the escape key give this alert text&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 *
 * &gt; Note: Does not work correctly in Firefox with special keys
 * 
 * @api
 * @method sendKeys
 * @param {string} selector Selector of the form field to be filled
 * @param {string} keystrokes Text to be applied to the element
 * @chainable
 */

Actions.prototype.sendKeys = function (selector, keystrokes) {
  var hash = uuid();

  if (this.querying === true) {
    keystrokes = selector;
    selector = this.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;sendKeys&#x27;, &#x27;sendKeys&#x27;, selector, keystrokes, hash);
  this._addToActionQueue([selector, keystrokes], &#x27;sendKeys&#x27;, cb);
  return this;
};

/**
 * Types a text into the text input field of a prompt dialog.
 * Like you would do when using your keyboard.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div&gt;
 *   &lt;a id=&quot;aquestion&quot; onclick=&quot;this.innerText = window.prompt(&#x27;Your favourite companion:&#x27;)&quot;&gt;????&lt;/a&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *     .click(&#x27;#aquestion&#x27;)
 *     .answer(&#x27;Rose&#x27;)
 *     .assert.text(&#x27;#aquestion&#x27;).is(&#x27;Rose&#x27;, &#x27;Awesome she was!&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 *
 * &gt; Note: Does not work in Firefox &amp; PhantomJS
 * 
 * @api
 * @method answer
 * @param {string} keystrokes Text to be applied to the element
 * @return chainable
 */

Actions.prototype.answer = function (keystrokes) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;promptText&#x27;, &#x27;promptText&#x27;, keystrokes, hash);
  this._addToActionQueue([keystrokes, hash], &#x27;promptText&#x27;, cb);
  return this;
};

/**
 * Executes a JavaScript function within the browser context
 * 
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *     .execute(function () {
 *       window.myFramework.addRow(&#x27;foo&#x27;);
 *       window.myFramework.addRow(&#x27;bar&#x27;);
 *     })
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * You can also apply arguments to the function
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *     .execute(function (paramFoo, aBar) {
 *       window.myFramework.addRow(paramFoo);
 *       window.myFramework.addRow(aBar);
 *     }, &#x27;foo&#x27;, &#x27;bar&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; Note: Buggy in Firefox
 * 
 * @api
 * @method execute
 * @param {function} script JavaScript function that should be executed
 * @return chainable
 */

Actions.prototype.execute = function (script) {
  var hash = uuid();
  var args = [this.contextVars].concat(Array.prototype.slice.call(arguments, 1) || []);
  var cb = this._generateCallbackAssertion(&#x27;execute&#x27;, &#x27;execute&#x27;, script, args, hash);
  this._addToActionQueue([script, args, hash], &#x27;execute&#x27;, cb);
  return this;
};

/**
 * Waits until a function returns true to process any next step.
 *
 * You can also set a callback on timeout using the onTimeout argument,
 * and set the timeout using the timeout one, in milliseconds. The default timeout is set to 5000ms.
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *     .waitFor(function () {
 *       return window.myCheck === true;
 *     })
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * You can also apply arguments to the function, as well as a timeout
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *     .waitFor(function (aCheck) {
 *       return window.myThing === aCheck;
 *     }, [&#x27;arg1&#x27;, &#x27;arg2&#x27;], 10000)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; Note: Buggy in Firefox
 * 
 * @method waitFor
 * @param {function} fn Async function that resolves an promise when ready
 * @param {array} args Additional arguments
 * @param {number} timeout Timeout in miliseconds
 * @chainable
 * @api
 */

Actions.prototype.waitFor = function (script, args, timeout) {
  var hash = uuid();
  timeout = timeout || 5000;
  args = [this.contextVars].concat(Array.prototype.slice.call(arguments, 1) || []);
  var cb = this._generateCallbackAssertion(&#x27;waitFor&#x27;, &#x27;waitFor&#x27;, script, args, timeout, hash);
  this._addToActionQueue([script, args, timeout, hash], &#x27;waitFor&#x27;, cb);
  return this;
};

/**
 * Accepts an alert/prompt/confirm dialog. This is basically the same actions as when
 * you are clicking okay or hitting return in one of that dialogs.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div&gt;
 *   &lt;a id=&quot;attentione&quot; onclick=&quot;window.alert(&#x27;Alonsy!&#x27;)&quot;&gt;ALERT!ALERT!&lt;/a&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *     // alert appears
 *     .click(&#x27;#attentione&#x27;)
 *     // alert is gone
 *     .accept()
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; Note: Does not work in Firefox &amp; PhantomJS
 * 
 * @api
 * @method accept
 * @return chainable
 */

Actions.prototype.accept = function () {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;acceptAlert&#x27;, &#x27;acceptAlert&#x27;, hash);
  this._addToActionQueue([hash], &#x27;acceptAlert&#x27;, cb);
  return this;
};

/**
 * Dismisses an prompt/confirm dialog. This is basically the same actions as when
 * you are clicking cancel in one of that dialogs.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div&gt;
 *   &lt;a id=&quot;nonono&quot; onclick=&quot;(this.innerText = window.confirm(&#x27;No classic doctors in the 50th?&#x27;) ? &#x27;Buh!&#x27; : &#x27;:(&#x27;) &quot;&gt;What!&lt;/a&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *     // prompt appears
 *     .click(&#x27;#nonono&#x27;)
 *     // prompt is gone
 *     .dismiss()
 *     .assert.text(&#x27;#nonono&#x27;).is(&#x27;:(&#x27;, &#x27;So sad&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; Note: Does not work in Firefox &amp; PhantomJS
 * 
 * @api
 * @method dismiss
 * @return chainable
 */

Actions.prototype.dismiss = function () {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;dismissAlert&#x27;, &#x27;dismissAlert&#x27;, hash);
  this._addToActionQueue([hash], &#x27;dismissAlert&#x27;, cb);
  return this;
};

/**
 * Resizes the browser window to a set of given dimensions (in px).
 * The default configuration of dalek opening pages is a width of 1280px
 * and a height of 1024px. You can specify your own default in the configuration.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div&gt;
 *   &lt;span id=&quot;magicspan&quot;&gt;The span in the fireplace&lt;/span&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;css
 * #magicspan {
 *   display: inline;
 * }
 *
 * // @media all and (max-width: 500px) and (min-width: 300px)
 * #magicspan {
 *   display: none;
 * }
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *     .assert.visible(&#x27;#magicspan&#x27;, &#x27;Big screen, visible span&#x27;)
 *     .resize({width: 400, height: 500})
 *     .assert.notVisible(&#x27;#magicspan&#x27;, &#x27;Small screen, no visible span magic!&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 *
 * &gt; Note: Does not work in Firefox
 * 
 * @api
 * @method resize
 * @param {object} dimensions Width and height as properties to apply
 * @chainable
 */

Actions.prototype.resize = function (dimensions) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;resize&#x27;, &#x27;resize&#x27;, dimensions, hash);
  this._addToActionQueue([dimensions, hash], &#x27;resize&#x27;, cb);
  return this;
};

/**
 * Maximizes the browser window.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div&gt;
 *   &lt;span id=&quot;magicspan&quot;&gt;The span in the fireplace&lt;/span&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;css
 * #magicspan {
 *   display: inline;
 * }
 *
 * @media all and (max-width: 500px) and (min-width: 300px) {
 *   #magicspan {
 *     display: none;
 *   }
 * }
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *     .resize({width: 400, height: 500})
 *     .assert.notVisible(&#x27;#magicspan&#x27;, &#x27;Small screen, no visible span magic!&#x27;)
 *     .maximize()
 *     .assert.visible(&#x27;#magicspan&#x27;, &#x27;Big screen, visible span&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * &gt; Note: Does not work in Firefox and PhantomJS
 * 
 * @api
 * @method maximize
 * @chainable
 */

Actions.prototype.maximize = function () {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;maximize&#x27;, &#x27;maximize&#x27;, hash);
  this._addToActionQueue([hash], &#x27;maximize&#x27;, cb);
  return this;
};

/**
 * Sets a cookie.
 * More configuration options will be implemented in the future,
 * by now, you can only set a cookie with a specific name and contents.
 * This will be a domain wide set cookie.
 *
 * &#x60;&#x60;&#x60;javascript
 *  test.open(&#x27;http://adomain.com&#x27;)
 *      .setCookie(&#x27;my_cookie_name&#x27;, &#x27;my=content&#x27;)
 *      .done();
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method setCookie
 * @chainable
 */

Actions.prototype.setCookie = function (name, contents) {
  var hash = uuid();
  var cb = this._generateCallbackAssertion(&#x27;setCookie&#x27;, &#x27;setCookie&#x27;, name, contents, hash);
  this._addToActionQueue([name, contents, hash], &#x27;setCookie&#x27;, cb);
  return this;
};

/**
 * Waits until an element matching the provided
 * selector expression exists in remote DOM to process any next step.
 *
 * Lets assume we have a ticker that loads its contents via AJAX,
 * and appends new elements, when the call has been successfully answered:
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://myticker.org&#x27;)
 *   .assert.text(&#x27;.ticker-element:first-child&#x27;, &#x27;First!&#x27;, &#x27;First ticker element is visible&#x27;)
 *   // now we load the next ticker element, defsult timeout is 5 seconds
 *   .waitForElement(&#x27;.ticker-element:nth-child(2)&#x27;)
 *   .assert.text(&#x27;.ticker-element:nth-child(2)&#x27;, &#x27;Me snd. one&#x27;, &#x27;Snd. ticker element is visible&#x27;)
 *   // Lets assume that this AJAX call can take longer, so we raise the default timeout to 10 seconds
 *   .waitForElement(&#x27;.ticker-element:last-child&#x27;, 10000)
 *   .assert.text(&#x27;.ticker-element:last-child&#x27;, &#x27;Me, third one!&#x27;, &#x27;Third ticker element is visible&#x27;)
 *   .done();
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method waitForElement
 * @param {string} selector Selector that matches the element to wait for
 * @param {number} timeout Timeout in milliseconds
 * @chainable
 */

Actions.prototype.waitForElement = function (selector, timeout) {
  var hash = uuid();

  if (this.querying === true) {
    timeout = selector;
    selector = this.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;waitForElement&#x27;, &#x27;waitForElement&#x27;, selector + &#x27; : &#x27; + timeout, hash);
  this._addToActionQueue([selector, (timeout ? parseInt(timeout, 10) : 5000), hash], &#x27;waitForElement&#x27;, cb);
  return this;
};

/**
 * Fills the fields of a form with given values.
 *
 * &#x60;&#x60;&#x60;html
 * &lt;input type=&quot;text&quot; value=&quot;not really a value&quot; id=&quot;ijustwannahaveavalue&quot;/&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://dalekjs.com&#x27;)
 *     .setValue(&#x27;#ijustwannahaveavalue&#x27;, &#x27;a value&#x27;)
 *     .assert.val(&#x27;#ijustwannahaveavalue&#x27;, &#x27;a value&#x27;, &#x27;Value is changed&#x27;);
 * &#x60;&#x60;&#x60;
 *
 * @api
 * @method setValue
 * @param {string} selector
 * @param {string} value
 * @return {Actions}
 */

Actions.prototype.setValue = function (selector, value) {
  var hash = uuid();

  if (this.querying === true) {
    value = selector;
    selector = this.selector;
  }

  var cb = this._generateCallbackAssertion(&#x27;setValue&#x27;, &#x27;setValue&#x27;, selector + &#x27; : &#x27; + value, hash);
  this._addToActionQueue([selector, value, hash], &#x27;setValue&#x27;, cb);
  return this;
};

// LOG (May should live in its own module)
// ---------------------------------------

Actions.prototype.logger = {};

/**
 * Logs a part of the remote dom
 *
 * &#x60;&#x60;&#x60;html
 * &lt;body&gt;
 *   &lt;div id=&quot;smth&quot;&gt;
 *     &lt;input type=&quot;hidden&quot; value=&quot;not really a value&quot; id=&quot;ijustwannahaveavalue&quot;/&gt;
 *   &lt;/div&gt;
 * &lt;/body&gt;
 * &#x60;&#x60;&#x60;
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://dalekjs.com/guineapig&#x27;)
 *     .log.dom(&#x27;#smth&#x27;)
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * Will output this:
 *
 * &#x60;&#x60;&#x60;html
 *  DOM: #smth &lt;input type=&quot;hidden&quot; value=&quot;not really a value&quot; id=&quot;ijustwannahaveavalue&quot;/&gt;
 * &#x60;&#x60;&#x60;

 * 
 * @api
 * @method log.dom
 * @param {string} selector CSS selector
 * @chainable
 */

Actions.prototype.logger.dom = function (selector) {
  var hash = uuid();

  var cb = function logDomCb (data) {
    if (data &amp;&amp; data.key === &#x27;source&#x27; &amp;&amp; !this.uuids[data.uuid]) {
      this.uuids[data.uuid] = true;
      var $ = cheerio.load(data.value);
      var result = selector ? $(selector).html() : $.html();
      selector = selector ? selector : &#x27; &#x27;;
      result = !result ? &#x27; Not found&#x27; : result;
      this.reporter.emit(&#x27;report:log:user&#x27;, &#x27;DOM: &#x27; + selector + &#x27; &#x27; + result);
    }
  }.bind(this);

  this._addToActionQueue([hash], &#x27;source&#x27;, cb);
  return this;
};

/**
 * Logs a user defined message
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://dalekjs.com/guineapig&#x27;)
 *     .execute(function () {
 *       this.data(&#x27;aKey&#x27;, &#x27;aValue&#x27;);
 *     })
 *     .log.message(function () {
 *       return test.data(&#x27;aKey&#x27;); // outputs MESSAGE: &#x27;aValue&#x27;
 *     })
 *     .done();
 * &#x60;&#x60;&#x60;
 *
 * &#x27;Normal&#x27; messages can be logged too:
 *
 * &#x60;&#x60;&#x60;javascript
 * test.open(&#x27;http://dalekjs.com/guineapig&#x27;)
 *     .log.message(&#x27;FooBar&#x27;) // outputs MESSAGE: FooBar
 *     .done();
 * &#x60;&#x60;&#x60;
 * 
 * @api
 * @method log.message
 * @param {function|string} message
 * @chainable
 */

Actions.prototype.logger.message = function (message) {
  var hash = uuid();

  var cb = function logMessageCb (data) {
    if (data &amp;&amp; data.key === &#x27;noop&#x27; &amp;&amp; !this.uuids[data.hash]) {
      this.uuids[data.hash] = true;
      var result = (typeof(data.value) === &#x27;function&#x27;) ? data.value.bind(this)() : data.value;
      this.reporter.emit(&#x27;report:log:user&#x27;, &#x27;MESSAGE: &#x27; + result);
    }
  }.bind(this);

  this._addToActionQueue([message, hash], &#x27;noop&#x27;, cb);
  return this;
};

/**
 * Generates a callback that will be fired when the action has been completed.
 * The callback itself will then validate the answer and will also emit an event
 * that the action has been successfully executed.
 *
 * @method _generateCallbackAssertion
 * @param {string} key Unique key of the action
 * @param {string} type Type of the action (normalle the actions name)
 * @return {function} The generated callback function
 * @private
 */

Actions.prototype._generateCallbackAssertion = function (key, type) {
  var cb = function (data) {
    if (data &amp;&amp; data.key === key &amp;&amp; !this.uuids[data.uuid]) {
      if (!data || (data.value &amp;&amp; data.value === null)) {
        data.value = &#x27;&#x27;;
      }

      if (key === &#x27;execute&#x27;) {
        Object.keys(data.value.dalek).forEach(function (key) {
          this.contextVars[key] = data.value.dalek[key];
        }.bind(this));

        data.value.test.forEach(function (test) {
          this.reporter.emit(&#x27;report:assertion&#x27;, {
            success: test.ok,
            expected: true,
            value: test.ok,
            message: test.message,
            type: &#x27;OK&#x27;
          });

          this.incrementExpectations();

          if (!test.ok) {
            this.incrementFailedAssertions();
          }
        }.bind(this));

        data.value = &#x27;&#x27;;
      }

      this.uuids[data.uuid] = true;
      reporter.emit(&#x27;report:action&#x27;, {
        value: data.value,
        type: type,
        uuid: data.uuid
      });
    }
  }.bind(this);
  return cb;
};

/**
 * Adds a method to the queue of actions/assertions to execute
 *
 * @method _addToActionQueue
 * @param {object} opts Options of the action to invoke
 * @param {string} driverMethod Name of the method to call on the driver
 * @param {function} A callback function that will be executed when the action has been executed
 * @private
 * @chainable
 */

Actions.prototype._addToActionQueue = function (opts, driverMethod, cb) {
  this.actionPromiseQueue.push(function () {
    var deferred = Q.defer();
    // add a generic identifier as the last argument to any action method call
    opts.push(uuid());
    // check the method on the driver object &amp;&amp; the callback function
    if (typeof(this.driver[driverMethod]) === &#x27;function&#x27; &amp;&amp; typeof(cb) === &#x27;function&#x27;) {
      // call the method on the driver object
      this.driver[driverMethod].apply(this.driver, opts);
      deferred.resolve();
    } else {
      deferred.reject();
    }

    // listen to driver message events &amp; apply the callback argument
    this.driver.events.on(&#x27;driver:message&#x27;, cb);
    return deferred.promise;
  }.bind(this));
  return this;
};

Actions.prototype._button = function(button) {
  var buttons = {LEFT: 0, MIDDLE: 1, RIGHT: 2};
  
  if (button === undefined) {
    button = 0;
  } else if (typeof button !== &#x27;number&#x27;) {
    button = buttons[button.toUpperCase()] || 0;
  }
  
  return button;
};

// http://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/click
Actions.prototype.buttonClick = function (button) {
  var hash = uuid();
  button = this._button(button);
  
  var cb = this._generateCallbackAssertion(&#x27;buttonClick&#x27;, &#x27;buttonClick&#x27;);
  this._addToActionQueue([button, hash], &#x27;buttonClick&#x27;, cb);
  
  return this;
};

// http://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/moveto
Actions.prototype.moveTo = function (selector, x, y) {
  var hash = uuid();
  
  if (this.querying === true) {
    selector = this.selector;
  }
  
  if (x === undefined) {
    x = null;
  }
  
  if (y === undefined) {
    y = null;
  }
  
  // move to coordinate
  var cb = this._generateCallbackAssertion(&#x27;moveto&#x27;, &#x27;moveto&#x27;);
  this._addToActionQueue([selector, x, y, hash], &#x27;moveto&#x27;, cb);

  return this;
};

/**
 * @module DalekJS
 */

module.exports = function (opts) {
  reporter = opts.reporter;
  return Actions;
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
